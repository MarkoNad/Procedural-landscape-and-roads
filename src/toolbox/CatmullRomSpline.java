package toolbox;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.lwjgl.util.vector.Vector3f;

public class CatmullRomSpline {
	
	private final List<Vector3f> controlPoints;
	private final float segmentLen;
	
	private List<Vector3f> splinePoints;
	private List<Float> trajectoryPointsDistances; // splineLenghts[0] = 0, splineLenghts[1] = distance(p0, p1)
	
	public CatmullRomSpline(List<Vector3f> controlPoints, float segmentLen) {
		if(controlPoints == null) {
			throw new IllegalArgumentException("Control points cannot be null.");
		}
		if(controlPoints.size() < 2) {
			throw new IllegalArgumentException("At least two points are required.");
		}
		
		this.controlPoints = controlPoints;
		this.segmentLen = segmentLen;
		generateCurve();
		determineLengths();
	}

	private void generateCurve() {
		splinePoints = new ArrayList<>();
		
		// first two points are linearly interpolated
		// the last point is not added, since it will be generated by the first true Catmull - Rom segment
		List<Vector3f> startLinearSegment = linearInterpolation(controlPoints.get(0), controlPoints.get(1));
		splinePoints.addAll(startLinearSegment.subList(0, startLinearSegment.size() - 1));
		
		for(int point = 1; point < controlPoints.size() - 2; point++) {
			Vector3f p0 = controlPoints.get(point - 1);
			Vector3f p1 = controlPoints.get(point);
			Vector3f p2 = controlPoints.get(point + 1);
			Vector3f p3 = controlPoints.get(point + 2);
			
			// calculate the segment between p1 and p2
			float distance = Vector3f.sub(p0, p1, null).length();
			int npoints = Math.max(2, (int) (distance / segmentLen) + 1);
			
			// edge point is not included
			for(int i = 0; i < npoints - 1; i++) {
				float t = i / (float)(npoints - 1);
				
				float curvex = 0.5f * (
						2 * p1.x + 
						t * (-p0.x + p2.x) + 
						t * t * (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) + 
						t * t * t * (-p0.x + 3 * p1.x - 3 * p2.x + p3.x)
				);
				float curvey = 0.5f * (
						2 * p1.y + 
						t * (-p0.y + p2.y) + 
						t * t * (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) + 
						t * t * t * (-p0.y + 3 * p1.y - 3 * p2.y + p3.y)
				);
				float curvez = 0.5f * (
						2 * p1.z + 
						t * (-p0.z + p2.z) + 
						t * t * (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) + 
						t * t * t * (-p0.z + 3 * p1.z - 3 * p2.z + p3.z)
				);
				
				splinePoints.add(new Vector3f(curvex, curvey, curvez));
			}
		}
		
		// last two points are linearly interpolated
		// all points are taken
		List<Vector3f> endLinearSegment = linearInterpolation(controlPoints.get(controlPoints.size() - 2), 
				controlPoints.get(controlPoints.size() - 1));
		splinePoints.addAll(endLinearSegment);
	}
	
	
	private void determineLengths() {
		trajectoryPointsDistances = new ArrayList<>();
		trajectoryPointsDistances.add(0f);
		
		float totalDistance = 0f;
		
		for(int i = 1; i < splinePoints.size(); i++) {
			Vector3f p0 = splinePoints.get(i - 1);
			Vector3f p1 = splinePoints.get(i);
			
			float segmentLength = Vector3f.sub(p0, p1, null).length();
			totalDistance += segmentLength;
			
			trajectoryPointsDistances.add(totalDistance);
		}
	}

	public List<Vector3f> getCurvePoints() {
		return splinePoints;
	}
	
	public List<Float> getTrajectoryPointDistances() {
		return trajectoryPointsDistances;
	}
	
	private List<Vector3f> linearInterpolation(Vector3f p0, Vector3f p1) {
		float distance = Vector3f.sub(p0, p1, null).length();
		int npoints = Math.max(2, (int) (distance / segmentLen) + 1);
		
		List<Vector3f> points = new ArrayList<>();
		
		for(int i = 0; i < npoints; i++) {
			float t = i / (float)(npoints - 1);
			
			float curvex = (1 - t) * p0.x + t * p1.x;
			float curvey = (1 - t) * p0.y + t * p1.y;
			float curvez = (1 - t) * p0.z + t * p1.z;
			
			points.add(new Vector3f(curvex, curvey, curvez));
		}
		
		return points;
	}
	
	public List<Vector3f> getControlPoints() {
		return Collections.unmodifiableList(controlPoints);
	}

}
